#!/usr/bin/python -tt

import argparse
import os.path
import pprint
import shutil
import subprocess
import sys

import rpm


class Distro(object):
    """
    A representation of a distribution that uses rpm packages
    """
    def __init__(self, topdir, distpaths, arches, disttag, skip_debuginfo=True):
        self.topdir = topdir
        self.distpaths = distpaths
        self.arches = arches
        self.disttag = disttag
        self.skip_debuginfo = skip_debuginfo

    @property
    def distpath(self):
        return os.path.join(self.topdir, self.distpaths[0])

    def create_dirs(self):
        """
        Create the directory structure for this distro underneath the
        top-level directory.  Directories that already exist will be
        left alone.
        """
        if not os.path.isdir(self.distpath):
            os.makedirs(self.distpath)
        for arch in self.arches:
            archdir = os.path.join(self.distpath, arch)
            if not os.path.isdir(archdir):
                os.mkdir(archdir)
        for altpath in self.distpaths[1:]:
            # Create a relative symlink for each alternate path for this distro
            altpath = os.path.join(self.topdir, altpath)
            if not os.path.exists(altpath):
                relpath = os.path.relpath(self.distpath,
                                          os.path.dirname(altpath.rstrip('/')))
                os.symlink(relpath, altpath)

    def __find_dests_for_package(self, path):
        """
        Find all destinations for an rpm package based on its dist tag
        and architecture.
        """
        headers = get_rpm_headers(path)
        if not headers[rpm.RPMTAG_RELEASE].endswith(self.disttag):
            return []
        if (self.skip_debuginfo and
                headers[rpm.RPMTAG_NAME].endswith('-debuginfo')):
            return []
        dests = []
        for arch in self.arches:
            archpath = os.path.join(self.distpath, arch)
            if headers[rpm.RPMTAG_SOURCEPACKAGE]:
                # Source packages have arches, too, so the check for
                # that must go first.
                if arch == 'source':
                    dests.append(os.path.join(archpath,
                                              os.path.basename(path)))
            else:
                if headers[rpm.RPMTAG_ARCH] in (arch, 'noarch'):
                    dests.append(os.path.join(archpath,
                                              os.path.basename(path)))
        return dests

    def copy_package(self, path):
        """
        Find all destinations for an rpm package based on its dist tag
        and architecture, then optionally sign it and copy it to the
        appropriate destinations.

        This method will attempt to use hard links where possible.
        """
        dests = self.__find_dests_for_package(path)
        for dest in dests:
            try:
                os.link(path, dest)
                continue
            except OSError:
                pass
            # All dests are probably on the same filesystem, so see if
            # we can use a hard link from the first copy.
            if dest != dests[0] and os.path.isfile(dests[0]):
                try:
                    os.link(dests[0], dest)
                    continue
                except OSError:
                    pass
            shutil.copy2(path, dest)
        return dests

    ## TODO:  signature

    ## TODO:  createrepo


def get_rpm_headers(filename):
    rpmts = rpm.ts()
    rpmts.setVSFlags(rpm._RPMVSF_NOSIGNATURES)
    fileno = os.open(filename, os.O_RDONLY)
    try:
        headers = rpmts.hdrFromFdno(fileno)
    finally:
        os.close(fileno)
    return headers


def find_packages(path):
    if os.path.isfile(path):
        yield path
    else:
        for dirpath, _, filenames in os.walk(path):
            for filename in filenames:
                if filename.endswith('.rpm'):
                    yield os.path.join(dirpath, filename)


def main():
    ## TODO:  moving, signing tarballs
    parser = argparse.ArgumentParser(
        description='Sort code artifacts into a directory structure')
    parser.add_argument('paths', metavar='PATH', nargs='+',
                        help='one or more file paths to search for artifacts')
    parser.add_argument('-d', '--dest', required=True,
                        help='the top-level directory to sort artifacts into')
    parser.add_argument('-p', '--package-set', required=True, action='append',
                        metavar='DISTTAG:PATH,...:ARCH,...',
                        help=('combination of dist tag, destination file '
                              'path(s), and architecture(s) to sort packages '
                              'into'))
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='show where packages were stored')
    parser.add_argument('--skip-debuginfo', action='store_true',
                        help='skip debuginfo packages')
    args = parser.parse_args()
    distros = []
    for package_set in args.package_set:
        disttag, paths, arches = package_set.split(':')
        distros.append(Distro(args.dest, paths.split(','), arches.split(','),
                              disttag))
    path_map = {}
    for distro in distros:
        distro.create_dirs()
        for path in args.paths:
            for package_path in find_packages(path):
                path_map[package_path] = distro.copy_package(
                    package_path)
    if args.verbose:
        pprint.pprint(path_map)


if __name__ == '__main__':
    main()
